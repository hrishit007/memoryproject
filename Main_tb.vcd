$date
	Thu Nov 10 04:08:17 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module Main_tb $end
$var reg 12 ! memoryAddress [11:0] $end
$var reg 1 " readEnable $end
$var reg 1 # writeEnable $end
$var integer 32 $ writeData [31:0] $end
$scope module uut $end
$var wire 12 % memoryAddress [11:0] $end
$var wire 1 " readEnable $end
$var wire 32 & writeData [31:0] $end
$var wire 1 # writeEnable $end
$var reg 1 ' hitmiss $end
$var reg 5 ( hittag [4:0] $end
$var reg 5 ) tagNumber [4:0] $end
$var reg 7 * temp [6:0] $end
$var integer 32 + addressToMemory [31:0] $end
$var integer 32 , blockNumberInMemory [31:0] $end
$var integer 32 - data [31:0] $end
$var integer 32 . empty [31:0] $end
$var integer 32 / missmaxcount [31:0] $end
$var integer 32 0 offset [31:0] $end
$var integer 32 1 readhit [31:0] $end
$var integer 32 2 readmiss [31:0] $end
$var integer 32 3 set_number [31:0] $end
$var integer 32 4 way_number [31:0] $end
$var integer 32 5 way_number_temp [31:0] $end
$var integer 32 6 writehit [31:0] $end
$var integer 32 7 writemiss [31:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 8 i [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 9 j [31:0] $end
$scope begin $ivl_for_loop2 $end
$var integer 32 : k [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop10 $end
$var integer 32 ; i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop3 $end
$var integer 32 < i [31:0] $end
$scope begin $ivl_for_loop4 $end
$var integer 32 = j [31:0] $end
$upscope $end
$upscope $end
$scope begin $ivl_for_loop5 $end
$var integer 32 > i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop6 $end
$var integer 32 ? i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop7 $end
$var integer 32 @ i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop8 $end
$var integer 32 A i [31:0] $end
$upscope $end
$scope begin $ivl_for_loop9 $end
$var integer 32 B i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b10000 B
bx A
b100 @
b100 ?
b11111111111111111111111111111111 >
b10000 =
b100000000 <
b100 ;
b10000 :
b100 9
b1000 8
b0 7
b0 6
bx 5
b11111111111111111111111111111111 4
bx 3
b0 2
b0 1
bx 0
b11111111111111111111111111111111 /
b11111111111111111111111111111111 .
bx -
bx ,
bx +
bx *
bx )
bx (
0'
bx &
bx %
bx $
x#
x"
bx !
$end
#20
b100 ;
b1 7
b11 -
b10000 B
b0 4
b10 0
b100 ?
b0 .
b11111111111111111111111111111111 >
b10 ,
b10 3
b0 )
1#
0"
b11 $
b11 &
b100010 !
b100010 %
#40
b1 6
b110 -
b0 0
b100 ?
b0 5
b0 (
1'
b11111111111111111111111111111111 >
b1 .
b110 $
b110 &
b100000 !
b100000 %
#60
b1 1
b11 -
b10 0
b100 ?
b11111111111111111111111111111111 >
b1 .
1'
0#
1"
b11 $
b11 &
b100010 !
b100010 %
#80
b100 ;
b1 2
b0 -
b10000 B
b100 ?
b11111111111111111111111111111111 >
b0 .
0'
b100 ,
b100 3
b1000010 !
b1000010 %
#100
b100 ;
b10 7
b11110 -
b10000 B
b1 4
b100 ?
b11111111111111111111111111111111 >
b1 .
b1010 ,
b10 3
b1 )
1#
0"
b11110 $
b11110 &
b10100010 !
b10100010 %
#120
b100 ;
b10 2
b0 -
b10000 B
b10 4
b100 ?
b11111111111111111111111111111111 >
b10 .
b10010 ,
b10 )
0#
1"
b100100010 !
b100100010 %
#140
b100 ;
b11 2
b10000 B
b11 4
b100 ?
b11111111111111111111111111111111 >
b11 .
b11010 ,
b11 )
b110100010 !
b110100010 %
#160
b100 ;
b100 2
b10000 B
b10000 A
b10 +
b1100000 *
b111 /
b100 @
b0 4
b100 ?
b11111111111111111111111111111111 >
b11111111111111111111111111111111 .
b110010 ,
b110 )
b1100100010 !
b1100100010 %
#180
b100 ;
b11 7
b1001101 -
b10000 B
b10000 A
b1010 +
b1100001 *
b100 @
b111 /
b1 4
b100 ?
b11111111111111111111111111111111 >
b1110010 ,
b1110 )
1#
0"
b1001101 $
b1001101 &
b11100100010 !
b11100100010 %
#200
